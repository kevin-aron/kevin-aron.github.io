<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>组会分享TIMER-XL</title>
    <link href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/"/>
    <url>/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/</url>
    
    <content type="html"><![CDATA[<h3 id="TIMER-XL-LONG-CONTEXT-TRANSFORMERS-FOR-UNIFIED-TIME-SERIES-FORECASTING"><a href="#TIMER-XL-LONG-CONTEXT-TRANSFORMERS-FOR-UNIFIED-TIME-SERIES-FORECASTING" class="headerlink" title="TIMER-XL: LONG-CONTEXT TRANSFORMERS FOR UNIFIED TIME SERIES FORECASTING"></a>TIMER-XL: LONG-CONTEXT TRANSFORMERS FOR UNIFIED TIME SERIES FORECASTING</h3><p>长上下文Transformer 统一的时间序列预测。</p><p>从题目入手：</p><ul><li>长文本：NLP领域的Transformer学习成千上万的token间依赖，传统只能学几百个token。</li><li>统一预测：做出改变：1维的token 预测 下一个token 改成→ 2维的(多变量)。</li></ul><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305012709401.png" alt="image-20250305012709401"></p><p>图中介绍了何为token，以及不同模态（语言模型、视觉模型、时序模型）Transformer处理的上下文长度。</p><p>总结本文做了两个工作：</p><p>​1.使用了NLP领域的Transformer应用到时序领域来，能处理更长的时间依赖；<br>​2.在Transformer中包含了单变量、多变量（多目标变量&#x2F;多协变量+一目标变量）。</p><p>模型：使用decoder-only的Transformer，利用不同长度的上下文来捕捉因果依赖关系。</p><blockquote><p>因果（Causality）通常指的是模型在处理序列数据时，只能使用当前时间点之前的信息，而不能“看到”未来的信息。</p><p>通过“自注意力”和“因果掩码”实现。</p><p><strong>使用因果掩码（Causal Masking）：</strong> 在计算**注意力权重（Attention Weights）**时，对未来的时间步置零，使得模型在计算第 ttt 个时间步的预测时，只能看到时间步 ≤t\leq t≤t 的数据。</p><p><strong>解码器架构（Decoder-Only Architecture）：</strong> 采用<strong>自回归（Autoregressive）</strong> 方式进行预测，即模型逐步预测每个时间步的值，并将已预测的值输入到后续时间步的计算中，而不是一次性输出整个序列。</p></blockquote><p>创新：1.提出了通用的TimeAttention机制；2.位置编码。</p><blockquote><p>其中TimeAttention中提到了：Kronecker-based mask 和 RoPE 两个技术。</p></blockquote><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305012634197.png" alt="image-20250305012634197"></p><p>此为模型结构图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Time Series A &amp; B</span><br>时序A(蓝色)，时序B(黄色) 被分割成多个Patch Token，作为输入。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Variable Dependency 变量依赖</span><br>变量A和B之间存在依赖关系，A的值受B影响，反之亦然(绿色箭头)。<br>依赖矩阵C记录了不同变量间的关联程度。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同时序建模方式</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">(a) 单变量 Univariate</span><br>只考虑单个时间序列 + 时间掩码(确保只能看到过去的信息) + 没有跨变量依赖关系<br><span class="hljs-meta prompt_"># </span><span class="language-bash">(b) 多变量 Multivariate</span><br>处理多个时间序列 + 变量依赖矩阵C全为1(变量间存在相互影响) + 时间掩码T(因果)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">(c) 带协变量 With Covariate B</span><br>A是目标变量，B是协变量 + C采用自定义依赖关系(A依赖A,B;B依赖B) + 时间掩码T(因果)<br></code></pre></td></tr></table></figure><p><code>Kronecker 乘积</code> $ C⊗T $ </p><p><strong>变量依赖矩阵(时间因果) $C$ 与时间掩码 $T$ 通过 Kronecker 乘积</strong>，将变量间的依赖关系 <strong>(C)</strong> 和时间序列的因果结构 <strong>(T)</strong> 结合，形成一个完整的 <strong>注意力掩码（Attention Mask）</strong>。<strong>保证 Transformer 既能考虑时间因果性，又能捕获变量之间的相互影响</strong>。</p><p><code>RoPE</code> 旋转位置编码：旨在为Transformer模型提供<strong>相对位置信息</strong>。</p><p>$RoPE(Q,K)&#x3D;QR_θK^T$</p><p>其中，$R_{\theta}$ 是一个基于位置索引 $p$ 和一个预设的基数 $θ$ 生成的旋转矩阵。</p><p>&#x3D;&#x3D;RoPE <strong>在注意力计算时，利用旋转变换引入相对位置信息，而不是直接添加位置编码</strong>。&#x3D;&#x3D;</p><p><code>可学习的标量参数（Scalars）</code></p><p>$Attention(Q,K,V)&#x3D;softmax(\frac{S_1⋅QK^T}{S_2·\sqrt{d}})V$</p><p>在注意力机制中，每个注意力头（Attention Head）通常会处理不同的子空间信息。可以使用<strong>可学习的标量参数</strong>来调整不同变量的贡献。</p><p><code>TimeAttention 计算公式</code></p><p>$TimeAttention(H)&#x3D;Softmax(\frac{Mask(C⊗T)+A}{\sqrt{d_k}})HW_v.$</p><p>$Mask()$ 的作用 $M_{i,j} &#x3D; 1$ 该位置$&#x3D;0$；$M_{i,j} &#x3D; 0$ 该位置$&#x3D;-∞$。相当于做了一步它和邻接矩阵相加，更改邻接矩阵的步骤，算是一个小优化。</p><p>$H$   特征矩阵</p><p>$W_v$ 投影矩阵</p><p>$d_k &#x3D; \frac{D}{head数量}$ 缩放因子（D是隐藏层维度）</p><h4 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h4><p>分别对：上下文长度、单变量预测、多变量预测、协变量预测、零样本做了对比实验。</p><p>又对：模型效率进行了实验。</p><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305022448722.png" alt="image-20250305022448722"></p><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305022501776.png" alt="image-20250305022501776"></p><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305022518724.png" alt="image-20250305022518724"></p><p><img src="/./%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/image-20250305022531588.png" alt="image-20250305022531588"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用智能指针？"><a href="#为什么使用智能指针？" class="headerlink" title="为什么使用智能指针？"></a>为什么使用智能指针？</h3><p>智能指针使用的是RAII的思想，资源的获取和释放和对象的声明周期绑定(通过类)，避免手动释放内存，对象声明周期结束自动调用析构函数释放，<strong>避免内存泄漏</strong>。</p><p>比如悬空指针(指针指向的地址已经被销毁)，智能指针能避免这种情况发生。</p><blockquote><p>C++98提供了auto_ptr模板的解决方案 C++11新增了unique_ptr、shared_ptr、weak_ptr</p></blockquote><h3 id="auto-ptr-C-17中被完全移除-弃用"><a href="#auto-ptr-C-17中被完全移除-弃用" class="headerlink" title="auto_ptr(C++17中被完全移除&#x2F;弃用)"></a>auto_ptr(C++17中被完全移除&#x2F;弃用)</h3><p>auto_ptr是C++98中定义的智能指针模板，可以将new获得的地址赋值给auto_ptr类型的指针，当对象过期时，调用析构函数中的delete释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto_ptr声明方式：auto_ptr&lt;类型&gt; 变量名(new 类型);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">str_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这是一个字符串&quot;</span>))</span></span>;<br>auto_ptr&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ve_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>对于类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br>T *tptr = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">//只调用构造函数，不会调用析构函数，不会释放new出来的内存，需要手动delete</span><br><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;  <span class="hljs-comment">//等到tptr1的声明周期结束，还会调用析构函数(管理指针的类的析构)，再牵扯调用类的析构</span><br>cout &lt;&lt; tptr1-&gt;<span class="hljs-built_in">Display</span>() &lt;&lt; (*tptr).<span class="hljs-built_in">Display</span>() &lt;&lt; endl; <span class="hljs-comment">//智能指针重载了 *(返回普通对象) 和 -&gt;(返回指针对象) 运算符</span><br></code></pre></td></tr></table></figure><p>智能指针常用的三个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br><span class="hljs-comment">// get() 获取智能指针托管的指针地址</span><br>T *tmp = tptr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 一般不用这个操作</span><br>cout &lt;&lt; tmp-&gt;<span class="hljs-built_in">Display</span>();<br><span class="hljs-comment">// release() 取消智能指针对动态内存的托管</span><br>T *tmp2 = tptr.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//tptr不再指向原内存地址,指向NULL</span><br><span class="hljs-keyword">delete</span> tmp2;<br><span class="hljs-comment">//reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</span><br>tptr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//释放掉内存，将tptr指向NULL</span><br>tptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>()); <span class="hljs-comment">//释放掉内存，指向新的内存</span><br></code></pre></td></tr></table></figure><p>auto_ptr从C++11之后被抛弃的主要原因(<strong>被unique_ptr取代了</strong>)</p><ul><li>复制或赋值都会改变资源的所有权</li><li>在STL容器中使用非常危险，因为容器中的元素必须支持可复制和赋值(别把指针传入容器，就算使用了std::move()避免了，在容器中修改值也寄了)</li><li>不支持对象数组的内存管理(🚫auto_ptr&lt;int[]&gt; array(new int[5]);)因为auto_ptr并不会使用delete[]，会错误的使用delete释放，引发内存泄漏甚至崩溃(访问非法内存)</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>同auto_ptr的特性一样，有排他所有权模式：两个指针不能指向同一个资源</li><li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但是允许临时右值赋值构造和赋值</li><li>保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象</li><li>在容器中保存指针是安全的</li></ul><blockquote><p>使用 <code>std::move</code> 可以把左值转换成右值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>; <span class="hljs-comment">//p1被置为NULL，p3里是原p1指向的地址</span><br>p1 = std::<span class="hljs-built_in">move</span>(p2);                   <span class="hljs-comment">//同上，道理一样</span><br><br><span class="hljs-comment">//在 STL 容器中使用unique_ptr，不允许直接赋值</span><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec[<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">move</span>(vec[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">//支持对象数组的内存管理</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>除上述用法，其它与auto_ptr无差别。</p><p>初始化方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1(<span class="hljs-built_in">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1 = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>); //C++<span class="hljs-number">14</span>开始<br></code></pre></td></tr></table></figure><p>使用 <code>make_unique</code> 减少了手动使用new的需求；它将对象的构造函数和内存分配结合在一起，避免了潜在的内存泄漏；支持数组的安全初始化，自动使用delete[]释放数组；提供更好的(一丢丢) 性能和内存管理。</p><p>内存管理陷阱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;string&gt; p1, p2;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;内存管理陷阱&quot;</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(str);<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>(str); <span class="hljs-comment">//p2接管str指针，会先取消p1的托管，此时p1指向了NULL</span><br>cout &lt;&lt; *p1 &lt;&lt; endl; <span class="hljs-comment">//再使用p1时，会引发异常(内存错误)</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个指针变量共享内存。记录引用特定内存对象的智能指针数量，当复制时，引用计数+1，当智能指针析构时，引用计数-1，如果计数为0，代表已经没有指针指向这块内存，我们就可以释放了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">element_type* _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;    <span class="hljs-comment">//指向申请的内存</span><br>_Ref_count_base* _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;; <span class="hljs-comment">//指向引用计数</span><br></code></pre></td></tr></table></figure><p>1.引用计数的使用</p><p>调用use_count函数可以获得当前托管指针的引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br>p1 = p2;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//2</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p>2.构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br>T *tptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(tptr); <span class="hljs-comment">//托管tptr，不需要delete tptr了</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p1)</span></span>;<br><br>shared_ptr&lt;T[]&gt; p4;                      <span class="hljs-comment">//C++17后支持</span><br><span class="hljs-function">shared_ptr&lt;T[]&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;)</span></span>; <span class="hljs-comment">//C++17后支持</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>, DestructT())</span></span>;     <span class="hljs-comment">//空的指针，接受一个DestructT()类型的删除器，用它释放内存</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">8</span>), DestructT())</span></span>;<br></code></pre></td></tr></table></figure><p>3.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(up1)</span></span>;<br><span class="hljs-comment">//使用make_shared初始化对象，分配内存效率更高(推荐)</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>);<br>shared_ptr&lt;string&gt; up4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-string">&quot;string&quot;</span>);<br>shared_ptr&lt;T&gt; up5 = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-number">9</span>);<br><span class="hljs-comment">//赋值</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;<br>up6 = up7; <span class="hljs-comment">//int(10)的引用计数-1，int(11)的引用计数+1，up2共享int(11)给up1</span><br><span class="hljs-comment">//主动释放对象</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up8</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>up8 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//int(10)的引用计数-1，计数归零内存释放</span><br>up8 = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//作用同上</span><br><span class="hljs-comment">//重置</span><br>p.<span class="hljs-built_in">reset</span>();     <span class="hljs-comment">//将p重置为空指针，所管理的对象引用计数-1</span><br>p.<span class="hljs-built_in">reset</span>(p1);   <span class="hljs-comment">//将p重置为p1，p管理的对象计数-1，p接管的p1的对象计数+1</span><br>p.<span class="hljs-built_in">reset</span>(p1,d); <span class="hljs-comment">//同上，并使用d作为删除器</span><br><span class="hljs-comment">//交换</span><br>std::<span class="hljs-built_in">swap</span>(p1,p2); <span class="hljs-comment">//交换p1和p2管理的对象，原对象的引用计数不变</span><br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);      <span class="hljs-comment">//同上，swap()是shared_ptr中实现(重写)的，不需要加std</span><br></code></pre></td></tr></table></figure><p>shared_ptr使用陷阱</p><p>shared_ptr作为被管控的对象的成员时，小心因循环引用造成无法释放资源。</p><p>比如A类中有B类的智能指针，B类中有A类的智能指针，相互持有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解读：当useTrap()被调用，会初始化两个共享智能指针，spBoy指向Boy()内存，spGirl指向Girl()内存，然后进入交叉引用阶段，Boy()中有一个gF指针指向Girl()，Girl()中有一个bF指针指向Boy()。</p><img src="https://picx.zhimg.com/80/v2-3dc01c49b68a25febca39681a1fc9303_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>可以使用weak_ptr避免这种情况的发生。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>目的是为了配合shared_ptr而引用的一种智能指针来协助其工作的，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，它的构造和析构不会引起计数的增加或减少。</p><p>weak_ptr没有重载 * 和 -&gt;，但是可以使用lock获得一个可用的shared_ptr对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr wpGirl_1;<br><span class="hljs-function">weak_ptr <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>; <span class="hljs-comment">//使用shared_ptr构造</span><br>wpGirl_1 = spGirl;         <span class="hljs-comment">//允许共享指针赋值给弱指针</span><br><br>wpGirl_<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>();      <span class="hljs-comment">//也可以获得引用计数</span><br><br>shared_ptr&lt;Girl&gt; sp_girl;   <span class="hljs-comment">//必要的时候可以转换成共享指针</span><br>sp_girl = wpGirl_<span class="hljs-number">1.l</span>ock();  <span class="hljs-comment">//使用lock()</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>上述问题代码改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    weak_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接解决问题！</p><p>weak_ptr的expired函数用法：判断当前weak_ptr智能指针是否还有托管的对象，有返回false，无返回true</p><p>如果返回true，相当于use_count()&#x3D;0，已经没有托管对象了。可以在使用指针前加以判断，保证指针是有效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr&lt;<span class="hljs-type">int</span>&gt; g;<br><span class="hljs-keyword">if</span>(!g.<span class="hljs-built_in">expired</span>()) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<span class="hljs-comment">//有效</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="智能指针的使用陷阱"><a href="#智能指针的使用陷阱" class="headerlink" title="智能指针的使用陷阱"></a>智能指针的使用陷阱</h3><ul><li>不要把一个原生指针给多个智能指针管理；</li><li>记得使用u.release()的返回值，这个返回值是这块内存的唯一索引，没有释放的话就内存泄漏了；</li><li>禁止使用delete智能指针get()得到的指针；</li><li>禁止使用任何类型智能指针get()返回的地址去初始化另一个智能指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++11新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
