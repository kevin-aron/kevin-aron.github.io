<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/categories/mit6.s081/Lab2%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/categories/mit6.s081/Lab2%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: Lab2：系统调用<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2025</span>-<span class="hljs-number">03</span>-<span class="hljs-number">04</span> <span class="hljs-number">03</span>:<span class="hljs-number">01</span>:<span class="hljs-number">25</span><br><span class="hljs-attribute">categories</span>: mit6.s081<br></code></pre></td></tr></table></figure><h3 id="Lab2：系统调用"><a href="#Lab2：系统调用" class="headerlink" title="Lab2：系统调用"></a>Lab2：系统调用</h3><p>切换分支：syscall</p><p>用户程序 - - (系统调用) - -→ 内核 </p><p>在操作系统中，系统调用是用户程序和内核进行交互的桥梁。用户程序无法直接操作硬件，不能直接访问内核提供的资源。系统调用运行用户程序通过受控接口向内核请求服务，保持系统的安全性和稳定性。</p><p><strong>一切为了实现用户态和内核态的良好隔离</strong></p><p>操作系统通过CPU的特权级模式，将用户态与内核态隔离，保证了用户程序无法直接访问内核资源，避免了误操作和恶意行为。</p><p>用户 →  库函数（系统调用）→ 触发软件中断or陷阱，引发CPU切换到内核态。</p><p>内核：根据系统调用号确定要执行的服务，完成后，将结果或错误码存入用户程序寄存器。</p><p>返回用户态继续执行程序。</p><p>在上述描述中，可以发现一直在强调用户态和内核态。</p><p>在xv6系统项目中，本实验也是围绕着 <code>user</code> 和 <code>kernel</code> 两个文件夹来操作。</p><p>用户态中，我需要声明跳板函数。内核态中，写对应的系统调用映射（system call），这里是用的c语言的一种实现方式 <code>static uint64 (*syscallsp[])(void) = &#123;&#125;</code> ，不过原理就是通过状态码建立起与调用函数的映射关系。状态码通过 <code>#define SYS_trace 22</code> 实现，不过在实习中，和书中都提到过尽量避免使用define，而是选择<code>typedef SYS_trace 22;</code> 之类的实现方法。</p><p>如何从用户态切换到内核态？本项目使用的是Perl脚本，通过 <code>entry(&quot;trace&quot;);</code> 的方式注册，大概是会被宏展开成一段汇编代码，生成 &#96;usys.S 汇编文件，定义了每个 system call 的用户态跳板函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">trace:# 定义用户态跳板函数<br>li a7, SYS_trace# 将系统调用 id 存入 a7 寄存器<br>ecall# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)<br>ret                 # 返回用户态<br></code></pre></td></tr></table></figure><p>实际上就是执行了 <code>ecall</code> 进入内核。</p><p> <code>ecall</code>（RISC-V 平台的系统调用指令），触发软件中断 trap，引导CPU进入内核态（S模式）。</p><p><code>ecall</code> 触发异常，进入 <strong>kernel&#x2F;trap.c</strong> 中的 <code>usertrap()</code> 处理。</p><p><code>usertrap()</code> 发现是系统调用异常，调用 <code>syscall()</code> 处理。</p><p><code>syscall()</code> 解析 <code>a7</code> 中的系统调用编号，并调用对应的 <code>sys_exit()</code> 等系统调用处理函数。</p><p>对于切换啰嗦了几句，再提一个更基础的知识点，就到下一个环节。</p><blockquote><p>上下文切换：多个进程 or 线程切换控制权。寄存器状态、程序计数器PC、栈指针、页表；进程控制块PCB。</p></blockquote><h4 id="实验：System-call-tracing"><a href="#实验：System-call-tracing" class="headerlink" title="实验：System call tracing"></a>实验：System call tracing</h4><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 « SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p><p>在本作业中，您将添加一个系统调用跟踪功能，该功能可能会在调试后续实验时为您提供帮助。您将创建一个新的跟踪系统调用，该调用将控制跟踪。它应该接受一个参数，一个整数 “mask”，其位指定要跟踪的系统调用。例如，为了跟踪 fork 系统调用，程序调用 trace（1 « SYS_fork），其中 SYS_fork 是 kernel&#x2F;syscall.h 中的系统调用编号。如果在掩码中设置了系统调用的编号，则必须修改 xv6 内核以在每个系统调用即将返回时打印出一行。该行应包含进程 ID、系统调用的名称和返回值;您无需打印系统调用参数。trace 系统调用应启用对调用它的进程及其随后分叉的任何子进程的跟踪，但不应影响其他进程。</p></blockquote><p>实现配置部分省略~照搬参考博客</p><p><strong>系统调用全过程</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">user/user<span class="hljs-selector-class">.h</span>:用户态程序调用跳板函数 <span class="hljs-built_in">trace</span>()<br>user/usys<span class="hljs-selector-class">.S</span>:跳板函数 <span class="hljs-built_in">trace</span>() 使用 CPU 提供的 ecall 指令，调用到内核态<br>kernel/syscall<span class="hljs-selector-class">.c</span>到达内核态统一系统调用处理函数 <span class="hljs-built_in">syscall</span>()，所有系统调用都会跳到这里来处理。<br>kernel/syscall<span class="hljs-selector-class">.c</span><span class="hljs-built_in">syscall</span>() 根据跳板传进来的系统调用编号，查询 syscalls<span class="hljs-selector-attr">[]</span> 表，找到对应的内核函数并调用。<br>kernel/sysproc<span class="hljs-selector-class">.c</span>到达 <span class="hljs-built_in">sys_trace</span>() 函数，执行具体内核操作<br></code></pre></td></tr></table></figure><ul><li>内核态与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过c语言参数的形式传过来，使用argaddr、argint、argstr等系列函数，从进程的trapframe中读取用户进程寄存器中的参数。</li><li>内核态与用户进程的页表不同，指针也不能直接互通访问（不能直接对拿到的指针解引用），使用copyin、copyout方法结合进程的页表，顺利找到用户态指针（逻辑地址）对应的物理内存地址。</li></ul><blockquote><p>页表：记录虚拟页到物理页框的映射关系。</p></blockquote><p><strong>实验逻辑部分</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    ...<br>    uint64 syscall_trace;        <br>    <span class="hljs-comment">// Mask for syscall tracing (新添加的用于标识追踪哪些 system call 的 mask)</span><br>&#125;; <br><br><span class="hljs-comment">// kernel/proc.c</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    p-&gt;syscall_trace = <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// (newly added) 为 syscall_trace 设置一个 0 的默认值</span><br>&#125;<br><br><span class="hljs-comment">// kernel/sysproc.c</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> mask;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 通过读取进程的 trapframe，获得 mask 参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  myproc()-&gt;syscall_trace = mask; <span class="hljs-comment">// 设置调用进程的 syscall_trace mask</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// kernel/proc.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="hljs-comment">//子进程继承父进程的 syscall_trace</span><br>&#125;<br><br><span class="hljs-comment">// kernel/syscall.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; <br>      <span class="hljs-comment">// 如果系统调用编号有效</span><br>    p-&gt;trapframe-&gt;a0 = syscalls[num](); <br>      <span class="hljs-comment">// 通过系统调用编号，获取系统调用处理函数的指针，调用并将返回值存到用户进程的 a0 寄存器中</span><br><span class="hljs-comment">// 如果当前进程设置了对该编号系统调用的 trace，则打出 pid、系统调用名称和返回值。</span><br>    <span class="hljs-keyword">if</span>((p-&gt;syscall_trace &gt;&gt; num) &amp; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0); <br>      <span class="hljs-comment">// syscall_names[num]: 从 syscall 编号到 syscall 名的映射表</span><br>    &#125;<br>  &#125; <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// kernel/syscall.c</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *syscall_names[] = &#123;<br>[SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<br>[SYS_kill]    <span class="hljs-string">&quot;kill&quot;</span>,<br>[SYS_exec]    <span class="hljs-string">&quot;exec&quot;</span>,<br>[SYS_fstat]   <span class="hljs-string">&quot;fstat&quot;</span>,<br>[SYS_chdir]   <span class="hljs-string">&quot;chdir&quot;</span>,<br>[SYS_dup]     <span class="hljs-string">&quot;dup&quot;</span>,<br>[SYS_getpid]  <span class="hljs-string">&quot;getpid&quot;</span>,<br>[SYS_sbrk]    <span class="hljs-string">&quot;sbrk&quot;</span>,<br>[SYS_sleep]   <span class="hljs-string">&quot;sleep&quot;</span>,<br>[SYS_uptime]  <span class="hljs-string">&quot;uptime&quot;</span>,<br>[SYS_open]    <span class="hljs-string">&quot;open&quot;</span>,<br>[SYS_write]   <span class="hljs-string">&quot;write&quot;</span>,<br>[SYS_mknod]   <span class="hljs-string">&quot;mknod&quot;</span>,<br>[SYS_unlink]  <span class="hljs-string">&quot;unlink&quot;</span>,<br>[SYS_link]    <span class="hljs-string">&quot;link&quot;</span>,<br>[SYS_mkdir]   <span class="hljs-string">&quot;mkdir&quot;</span>,<br>[SYS_close]   <span class="hljs-string">&quot;close&quot;</span>,<br>[SYS_trace]   <span class="hljs-string">&quot;trace&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="实验：Sysinfo"><a href="#实验：Sysinfo" class="headerlink" title="实验：Sysinfo"></a>实验：Sysinfo</h4><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.<br>在此作业中，您将添加一个系统调用 sysinfo，用于收集有关正在运行的系统的信息。系统调用采用一个参数：指向 struct sysinfo 的指针（请参阅 kernel&#x2F;sysinfo.h）。内核应该填写这个结构体的字段：freemem 字段应该被设置为空闲内存的字节数，nproc 字段应该被设置为状态不是 UNUSED 的进程数。我们提供了一个测试程序 sysinfotest;如果它打印 “sysinfotest： OK”，则通过此赋值。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取空闲内存、获取运行的进程数</span><br><span class="hljs-comment">// kernel/defs.h</span><br>uint64 <span class="hljs-title function_">count_free_mem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// here</span><br>uint64<span class="hljs-title function_">count_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// here</span><br><br><span class="hljs-comment">// kernel/kalloc.c</span><br>uint64<br><span class="hljs-title function_">count_free_mem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">// added for counting free memory in bytes (lab2)</span><br>&#123;<br>  acquire(&amp;kmem.lock); <span class="hljs-comment">// 必须先锁内存管理结构，防止竞态条件出现</span><br>  <br>  <span class="hljs-comment">// 统计空闲页数，乘上页大小 PGSIZE 就是空闲的内存字节数</span><br>  uint64 mem_bytes = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span> =</span> kmem.freelist;<br>  <span class="hljs-keyword">while</span>(r)&#123;<br>    mem_bytes += PGSIZE;<br>    r = r-&gt;next;<br>  &#125;<br><br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">return</span> mem_bytes;<br>&#125;<br><br><span class="hljs-comment">// kernel/proc.c</span><br>uint64<br><span class="hljs-title function_">count_process</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; <span class="hljs-comment">// added function for counting used process slots (lab2)</span><br>  uint64 cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">struct</span> proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-comment">// acquire(&amp;p-&gt;lock);</span><br>    <span class="hljs-comment">// 不需要锁进程 proc 结构，因为我们只需要读取进程列表，不需要写</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED) &#123; <span class="hljs-comment">// 不是 UNUSED 的进程位，就是已经分配的</span><br>        cnt++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// kernel/proc.c</span><br>uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// 从用户态读入一个指针，作为存放 sysinfo 结构的缓冲区</span><br>  uint64 addr;<br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">sinfo</span>;</span><br>  sinfo.freemem = count_free_mem(); <span class="hljs-comment">// kalloc.c</span><br>  sinfo.nproc = count_process(); <span class="hljs-comment">// proc.c</span><br>  <br>  <span class="hljs-comment">// 使用 copyout，结合当前进程的页表，获得进程传进来的指针（逻辑地址）对应的物理地址</span><br>  <span class="hljs-comment">// 然后将 &amp;sinfo 中的数据复制到该指针所指位置，供用户进程使用。</span><br>  <span class="hljs-keyword">if</span>(copyout(myproc()-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;sinfo, <span class="hljs-keyword">sizeof</span>(sinfo)) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// user.h</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">uptime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span> <span class="hljs-comment">// 这里要声明一下 sysinfo 结构，供用户态使用。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/categories/KVstorageBaseRaft/1/"/>
    <url>/categories/KVstorageBaseRaft/1/</url>
    
    <content type="html"><![CDATA[<p>分布式系统：满足一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)三项中的两项。</p><p>数据一致性：数据一起变化，数据整齐划一。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于Epoll实现的Reactor模型</title>
    <link href="/categories/C++/%E5%9F%BA%E4%BA%8EEpoll%E5%AE%9E%E7%8E%B0%E7%9A%84Reactor%E6%A8%A1%E5%9E%8B/"/>
    <url>/categories/C++/%E5%9F%BA%E4%BA%8EEpoll%E5%AE%9E%E7%8E%B0%E7%9A%84Reactor%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="基于epoll的Reactor网络模型"><a href="#基于epoll的Reactor网络模型" class="headerlink" title="基于epoll的Reactor网络模型"></a>基于epoll的Reactor网络模型</h3><h4 id="Epoll-API"><a href="#Epoll-API" class="headerlink" title="Epoll API"></a>Epoll API</h4><h5 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h5><p><code>epoll_create</code> 用于创建一个 <code>epoll</code> 实例，返回一个 <code>epoll</code> 句柄（文件描述符 <code>epfd</code>），用于后续 <code>epoll_ctl</code>、<code>epoll_wait</code> 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">//旧版需要指定 size，但它的值不会影响 epoll 句柄的行为，通常填 1 即可</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;   <br><span class="hljs-comment">//新版： 0：默认行为 ；EPOLL_CLOEXEC：创建的 epoll 句柄在 exec() 后会自动关闭</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create1</span><span class="hljs-params">(<span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>创建成功后，<code>epfd</code> 就可以用于管理多个 <code>socket fd</code>。</p><h5 id="epoll-event"><a href="#epoll-event" class="headerlink" title="epoll_event"></a>epoll_event</h5><p><code>epoll_event</code> 结构体用于存储 <code>epoll</code> 监听的事件信息，包括<strong>触发的事件类型（<code>events</code>）和 关联的文件描述符（<code>data.fd</code>）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> &#123;<br>    <span class="hljs-type">uint32_t</span> events;  <span class="hljs-comment">// 事件类型（EPOLLIN, EPOLLOUT, EPOLLET 等）</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">// 用户自定义数据，通常存储 fd</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>events：EPOLLIN 可读事件、 EPOLLOUT 可写事件、 EPOLLET边缘触发(默认水平)、EPOLLERR 错误事件、 EPOLLRDHUP 对端关闭连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev;<br>ev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">// 监听可读事件，使用边缘触发模式</span><br>ev.data.fd = sockfd; <span class="hljs-comment">// 绑定 socket fd</span><br></code></pre></td></tr></table></figure><h5 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h5><p><code>epoll_ctl</code> 用于<strong>向 <code>epoll</code> 实例中添加、修改或删除文件描述符（fd）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br></code></pre></td></tr></table></figure><p><code>op</code>（操作类型）：</p><ul><li><code>EPOLL_CTL_ADD</code>：向 <code>epoll</code> 实例中添加 <code>fd</code></li><li><code>EPOLL_CTL_MOD</code>：修改 <code>fd</code> 监听的事件类型</li><li><code>EPOLL_CTL_DEL</code>：从 <code>epoll</code> 实例中删除 <code>fd</code></li></ul><p><code>fd</code>：要操作的文件描述符（socket fd）。</p><p><code>event</code>：<code>epoll_event</code> 结构体指针，<strong><code>EPOLL_CTL_DEL</code> 操作时可以传 <code>NULL</code></strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev;<br>ev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">// 监听可读事件，边缘触发</span><br>ev.data.fd = sockfd;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev) == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_ctl failed&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h5><p>等待 <code>epoll</code> 事件触发，获取就绪 <code>fd</code> 列表。</p><h5 id="epoll监听多客户端代码模板"><a href="#epoll监听多客户端代码模板" class="headerlink" title="epoll监听多客户端代码模板"></a>epoll监听多客户端代码模板</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象 epoll 套路写法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev, events[MAX_EVENTS];<br>epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br>ev.events = EPOLLIN;<br>ev.data.fd = sock_server;<br><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, server_fd, &amp;ev);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    event_count = <span class="hljs-built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; event_count; i++) &#123;<br>        <span class="hljs-type">int</span> fd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span> (fd == server_fd)<br>            <span class="hljs-comment">// 处理新连接</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 处理客户端消息</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">close</span>(epfd);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8080</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> server_fd, client_fd, epfd, event_count;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server_addr, client_addr;<br>    <span class="hljs-type">socklen_t</span> addr_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev, events[MAX_EVENTS];<br><br>    <span class="hljs-comment">// 创建服务器 socket</span><br>    server_fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_addr.s_addr = INADDR_ANY;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br><br>    <span class="hljs-built_in">bind</span>(server_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    <span class="hljs-built_in">listen</span>(server_fd, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 创建 epoll 实例</span><br>    epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 注册服务器 socket 到 epoll，监听新连接</span><br>    ev.events = EPOLLIN;<br>    ev.data.fd = server_fd;<br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, server_fd, &amp;ev);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server listening on port %d...\n&quot;</span>, PORT);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待事件</span><br>        event_count = <span class="hljs-built_in">epoll_wait</span>(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; event_count; i++) &#123;<br>            <span class="hljs-type">int</span> fd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span> (fd == server_fd) &#123;<br>                <span class="hljs-comment">// 处理新连接</span><br>                client_fd = <span class="hljs-built_in">accept</span>(server_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;addr_len);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New client connected: %d\n&quot;</span>, client_fd);<br>                <br>                ev.events = EPOLLIN;<br>                ev.data.fd = client_fd;<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, client_fd, &amp;ev);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理客户端消息</span><br>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>                <span class="hljs-type">int</span> bytes_read = <span class="hljs-built_in">read</span>(fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br>                <span class="hljs-keyword">if</span> (bytes_read &gt; <span class="hljs-number">0</span>) &#123;<br>                    buffer[bytes_read] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, buffer);<br>                    <span class="hljs-built_in">write</span>(fd, buffer, bytes_read); <span class="hljs-comment">// 回显</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 客户端断开连接</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Client %d disconnected\n&quot;</span>, fd);<br>                    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, fd, <span class="hljs-literal">NULL</span>);<br>                    <span class="hljs-built_in">close</span>(fd);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(server_fd);<br>    <span class="hljs-built_in">close</span>(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Epoll原理剖析"><a href="#Epoll原理剖析" class="headerlink" title="Epoll原理剖析"></a>Epoll原理剖析</h4><p>epoll的两个重要结构：rbtree 和 rdlist。</p><p>rbtree是红黑树结构，为了管理通过epoll_ctl注册在epoll上的文件描述符(如sock_fd)，插入，删除，查找均为O(logn)。</p><p>rdlist是用来存放接收缓冲区有数据的socket。这里细分为两种状态，ET(边缘触发)：数据到达，会触发事件通知，程序未完全读完缓冲区数据，下次也不会继续通知剩余部分；LT(水平触发)：只要缓冲区有数据，就会一直通过epoll_wait返回这些事件，直到读完为止。</p><p>这里大家可能有点懵逼，这和rdlist有什么关系？接下来会带着大家捋一下整个流程。</p><p>rdlist是epoll的结构体eventpoll中的一个成员变量，是epoll特有的。那之前IO复用是如何通知CPU将<strong>对应socket缓冲区有数据的进程</strong>重新放回工作队列中的呢，像select，采用的是“每个sock结构中的等待队列中放入它对应的进程，当接收缓冲区有数据的时候，发送中断信号，CPU重新把对应进程放入工作队列，此操作中，①查看缓冲区是否有数据，将有数据的进程从对应socket的等待队列中取出，放入工作队列，需要完整遍历一次socket列表；②在进程被唤醒后，需要知道哪些socket中有数据，通过FD_ISSET再判断出来，需要从用户态切换到内核态，且再遍历一次socket列表。”</p><blockquote><p>每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为<strong>遍历操作开销大</strong>，<strong>出于效率的考量</strong>，才会规定select的最大监视数量，默认只能监视<strong>1024个</strong>socket。</p></blockquote><p>那介绍完select后，说回来epoll。为什么需要用一个rdlist存socket？</p><p>因为可以减少遍历的次数。从设计上，epoll**(struct eventpoll)<strong>会和其它socket</strong>(struct sock)**一样，内核会创建一个对应的结构体，位于内核态(kmalloc分配的内存区域)，与调用进程绑定，此时。这种设计模式下，我们不会再把对应的阻塞进程加入到socket的等待队列中，而是通过epoll_ctl先将所有需要管理的socket注册到epoll中，当有进程因为epoll_wait被阻塞，将其放入eventpoll的等待队列中。当socket的接收缓冲区接收到数据后，会产生中断，中断程序会：①将接收到数据的socket的fd放入rdlist中(减少了一次查询遍历)；②唤醒在等待队列中的进程，再次进入运行态(减少了一次访问socket中进程，再删除的遍历)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">eventpoll</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mutex</span> mtx;              <span class="hljs-comment">// 互斥锁，保护数据结构</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rb_root_cached</span> rbr;     <span class="hljs-comment">// 红黑树，存储被监听的 fd</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span> rdlist;       <span class="hljs-comment">// 就绪事件链表</span><br>    <span class="hljs-type">wait_queue_head_t</span> wq;          <span class="hljs-comment">// 等待队列</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> *file;             <span class="hljs-comment">// 关联的文件描述符</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/images/Net/epoll_struct.jpeg" alt="epoll原理详解及epoll反应堆模型"></p><p>就绪列表引用着就绪的socket，所以它应能够快速的插入数据。所以就绪列表应是一种能够快速插入和删除的数据结构。</p><p>双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列（对应上图的rdlist）。</p><p>既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（对应上图的rbr）。</p><p>ps：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist并非直接引用socket，而是通过epitem间接引用，红黑树的节点也是epitem对象。同样，文件系统也并非直接引用着socket。</p><h4 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h4><p>高性能并发编程模型。应用：网络服务器、事件驱动编程。</p><p>利用I&#x2F;O多路复用(epoll, select, poll)处理并发连接。</p><p>**Reactor将IO管理，转变为事件管理。**不同的IO事件，对应不同的回调函数，先register，后callback。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//io        event      callback</span><br>  listenfd    EPOLLIN      accept_cb<br>  clientfd    EPOLLIN      recv_cb<br>  clientfd    EPOLLOUT      send_cb<br></code></pre></td></tr></table></figure><p><strong>Reactor 模式本质上是对 <code>epoll</code>（或其他 I&#x2F;O 多路复用机制）的封装</strong>，它提供了一种<strong>事件驱动的异步编程模型</strong>，用于高效处理多个 I&#x2F;O 连接。<code>Reactor</code> 是一种 <strong>编程模式</strong>，基于 <code>epoll</code> 组织事件循环，提高代码的扩展性和可维护性。</p><blockquote><p>大部分<strong>高性能网络框架（如 Nginx、Redis、Netty）都基于 Reactor 模式，并使用 <code>epoll</code> 作为底层实现</strong>。</p></blockquote><p>一个典型的 Reactor 框架会抽象出 <strong>事件分发器（Dispatcher）、事件处理器（Handler）</strong>.</p><p><strong>优势</strong>：</p><ul><li><strong>封装 <code>epoll</code>，提供面向对象的 API</strong></li><li><strong>支持回调机制</strong>（<code>handleEvent()</code>）</li><li><strong>更易扩展</strong>（可以用于不同的 I&#x2F;O 事件）</li></ul><p>直接使用epoll <strong>缺点</strong>：</p><ul><li>代码层面是<strong>面向系统调用</strong>的，难以扩展。</li><li>没有事件回调机制，必须手动遍历事件列表。</li></ul><h4 id="Reactor完整代码"><a href="#Reactor完整代码" class="headerlink" title="Reactor完整代码"></a>Reactor完整代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_LENGTH 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONNECTION_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*RCALLBACK)</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recv_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><br><span class="hljs-type">int</span> epfd = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">conn</span>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">char</span> rbuffer[BUFFER_LENGTH];<br><span class="hljs-type">int</span> rlength;<br><span class="hljs-type">char</span> wbuffer[BUFFER_LENGTH];<br><span class="hljs-type">int</span> wlength;<br>RCALLBACK send_callback;<br><span class="hljs-keyword">union</span>&#123;<br>RCALLBACK recv_callback;<br>RCALLBACK accept_callback;<br>&#125; r_action;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">conn</span> conn_list[CONNECTION_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">set_event</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> event, <span class="hljs-type">int</span> flag)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (flag)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev;<br>        ev.events = event;<br>        ev.data.fd = fd;<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, fd, &amp;ev);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">struct</span> epoll_event ev;<br>        ev.events = event;<br>        ev.data.fd = fd;<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_MOD, fd, &amp;ev);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">event_register</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> event)</span></span>&#123;<br><span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>conn_list[fd].fd = fd;<br>conn_list[fd].r_action.recv_callback = recv_cb; <span class="hljs-comment">// 读回调</span><br>    conn_list[fd].send_callback = send_cb;          <span class="hljs-comment">// 写回调</span><br><span class="hljs-built_in">memset</span>(conn_list[fd].rbuffer, <span class="hljs-number">0</span>, BUFFER_LENGTH);<br>    conn_list[fd].rlength = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(conn_list[fd].wbuffer, <span class="hljs-number">0</span>, BUFFER_LENGTH);<br>    conn_list[fd].wlength = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">set_event</span>(fd, event, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> clientaddr;<br><span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(clientaddr);<br><span class="hljs-type">int</span> clientfd = <span class="hljs-built_in">accept</span>(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept finished: %d\n&quot;</span>, clientfd);<br><span class="hljs-keyword">if</span>(clientfd &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept errno: %d --&gt; %s\n&quot;</span>, errno, <span class="hljs-built_in">strerror</span>(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">event_register</span>(clientfd, EPOLLIN);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recv_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-built_in">recv</span>(fd, conn_list[fd].rbuffer, BUFFER_LENGTH, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client disconnect: %d\n&quot;</span>, fd);<br>        <span class="hljs-built_in">close</span>(fd);<br>        <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, fd, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 从 epoll 删除</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>conn_list[fd].rlength = count;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;RECV: %s\n&quot;</span>, conn_list[fd].rbuffer);<br><br>conn_list[fd].wlength = conn_list[fd].rlength;<br><span class="hljs-built_in">memcpy</span>(conn_list[fd].wbuffer, conn_list[fd].rbuffer, conn_list[fd].wlength);<br><span class="hljs-built_in">set_event</span>(fd, EPOLLOUT, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">send_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-built_in">send</span>(fd, conn_list[fd].wbuffer, conn_list[fd].wlength, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">set_event</span>(fd, EPOLLIN, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_server</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span></span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    <span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">init_server</span>(<span class="hljs-number">2000</span>);<br>    conn_list[sockfd].fd = sockfd;<br>    conn_list[sockfd].r_action.recv_callback = accept_cb;<br>    <span class="hljs-built_in">set_event</span>(sockfd, EPOLLIN, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> events[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> nready = <span class="hljs-built_in">epoll_wait</span>(epfd, events, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nready; ++i)&#123;<br>            <span class="hljs-type">int</span> connfd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) conn_list[connfd].r_action.<span class="hljs-built_in">recv_callback</span>(connfd);<br>            <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT) conn_list[connfd].<span class="hljs-built_in">send_callback</span>(connfd);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Rector函数说明"><a href="#Rector函数说明" class="headerlink" title="Rector函数说明"></a>Rector函数说明</h4><h5 id="1-set-event-int-fd-int-event-int-flag"><a href="#1-set-event-int-fd-int-event-int-flag" class="headerlink" title="1. set_event(int fd, int event, int flag)"></a><strong>1. <code>set_event(int fd, int event, int flag)</code></strong></h5><p><strong>作用</strong>：配置 <code>epoll</code> 事件，将 <code>fd</code> 注册到 <code>epoll</code> 实例中，并指定监听的事件类型。<br><strong>参数</strong>：</p><ul><li><code>fd</code>：要监听的文件描述符（socket）。</li><li><code>event</code>：监听的事件（如 <code>EPOLLIN</code>、<code>EPOLLOUT</code>）。</li><li><code>flag</code>：操作类型（<code>EPOLL_CTL_ADD</code> 添加新 <code>fd</code>，<code>EPOLL_CTL_MOD</code> 修改 <code>fd</code> 的事件）。<br><strong>实现逻辑</strong>：</li><li>创建 <code>epoll_event</code> 结构体，设置事件类型。</li><li>调用 <code>epoll_ctl()</code> 在 <code>epoll</code> 实例中注册或修改 <code>fd</code> 事件。</li></ul><h5 id="2-event-register-int-fd-int-event"><a href="#2-event-register-int-fd-int-event" class="headerlink" title="2. event_register(int fd, int event)"></a><strong>2. <code>event_register(int fd, int event)</code></strong></h5><p><strong>作用</strong>：初始化并注册一个新的 <code>fd</code> 到 <code>epoll</code>，使其能够监听指定的事件。<br><strong>参数</strong>：</p><ul><li><code>fd</code>：需要注册的 <code>socket</code> 文件描述符。</li><li><code>event</code>：监听的事件类型（如 <code>EPOLLIN</code>）。<br><strong>实现逻辑</strong>：</li><li>为 <code>fd</code> 关联必要的资源（如 I&#x2F;O 缓冲区、回调函数）。</li><li>调用 <code>set_event()</code> 将其注册到 <code>epoll</code>，监听可读（<code>EPOLLIN</code>）或可写（<code>EPOLLOUT</code>）事件。</li></ul><h5 id="3-accept-cb-int-fd"><a href="#3-accept-cb-int-fd" class="headerlink" title="3. accept_cb(int fd)"></a><strong>3. <code>accept_cb(int fd)</code></strong></h5><p><strong>作用</strong>：当服务器监听的 <code>socket</code> 变为可读（表示有新连接）时，调用此回调函数接受新连接。<br><strong>参数</strong>：</p><ul><li><code>fd</code>：监听的服务器 <code>socket</code>。<br><strong>实现逻辑</strong>：</li><li>调用 <code>accept()</code> 接受新的客户端连接。</li><li>为新连接创建 <code>socket</code> 并设置非阻塞模式。</li><li>打印客户端连接信息（如 IP 地址、端口）。</li><li>调用 <code>event_register()</code> 注册新 <code>socket</code>，监听 <code>EPOLLIN</code> 事件（可读）。</li></ul><h5 id="4-recv-cb-int-fd"><a href="#4-recv-cb-int-fd" class="headerlink" title="4. recv_cb(int fd)"></a><strong>4. <code>recv_cb(int fd)</code></strong></h5><p><strong>作用</strong>：当 <code>fd</code> 变为可读（即有数据到达）时，调用此回调函数读取数据。<br><strong>参数</strong>：</p><ul><li><code>fd</code>：客户端的 <code>socket</code> 文件描述符。<br><strong>实现逻辑</strong>：</li><li>从 <code>fd</code> 读取数据到接收缓冲区。</li><li>处理收到的数据（如打印、回显）。</li><li>若客户端断开连接（<code>recv()</code> 返回 <code>0</code>），关闭 <code>fd</code> 并移除 <code>epoll</code> 监听。</li></ul><h5 id="5-send-cb-int-fd"><a href="#5-send-cb-int-fd" class="headerlink" title="5. send_cb(int fd)"></a><strong>5. <code>send_cb(int fd)</code></strong></h5><p><strong>作用</strong>：当 <code>fd</code> 变为可写（即发送缓冲区有空间）时，调用此回调函数发送数据。<br><strong>参数</strong>：</p><ul><li><code>fd</code>：客户端的 <code>socket</code> 文件描述符。<br><strong>实现逻辑</strong>：</li><li>从发送缓冲区取数据，写入 <code>fd</code>。</li><li>若数据发送完毕，将 <code>fd</code> 事件重新设置为 <code>EPOLLIN</code>，继续监听可读事件。</li><li>若未发送完全部数据，继续监听 <code>EPOLLOUT</code>，等待可写事件再次触发。</li></ul><h5 id="6-init-server-unsigned-short-port"><a href="#6-init-server-unsigned-short-port" class="headerlink" title="6. init_server(unsigned short port)"></a><strong>6. <code>init_server(unsigned short port)</code></strong></h5><p><strong>作用</strong>：初始化服务器，创建 <code>socket</code> 并监听指定端口，准备接受客户端连接。<br><strong>参数</strong>：</p><ul><li><code>port</code>：服务器监听的端口号。<br><strong>实现逻辑</strong>：</li><li>创建 <code>socket</code>，绑定 <code>port</code>，设置非阻塞模式。</li><li>调用 <code>listen()</code> 让 <code>socket</code> 进入监听模式。</li><li>调用 <code>event_register()</code> 将 <code>server_fd</code> 注册到 <code>epoll</code>，监听 <code>EPOLLIN</code> 事件（新连接）。</li></ul><p><strong>7. <code>main()</code></strong></p><p><strong>作用</strong>：程序主入口，负责初始化 <code>epoll</code> 事件循环，并分发 I&#x2F;O 事件。<br><strong>实现逻辑</strong>：</p><ol><li><p>创建 <code>epoll</code> 实例。</p></li><li><p>调用 <code>init_server(port)</code> 初始化服务器 <code>socket</code> 并注册到 <code>epoll</code>。</p></li><li><p>进入 epoll_wait()</p><p>事件循环：</p><ul><li>等待 <code>epoll</code> 事件触发。</li><li>根据 <code>fd</code> 状态调用相应的回调函数（<code>accept_cb</code>、<code>recv_cb</code>、<code>send_cb</code>）。</li><li>处理完毕后继续等待新的事件。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组会分享TIMER-XL</title>
    <link href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/"/>
    <url>/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BC%9A%E5%88%86%E4%BA%ABTIMER-XL/</url>
    
    <content type="html"><![CDATA[<h3 id="TIMER-XL-LONG-CONTEXT-TRANSFORMERS-FOR-UNIFIED-TIME-SERIES-FORECASTING"><a href="#TIMER-XL-LONG-CONTEXT-TRANSFORMERS-FOR-UNIFIED-TIME-SERIES-FORECASTING" class="headerlink" title="TIMER-XL: LONG-CONTEXT TRANSFORMERS FOR UNIFIED TIME SERIES FORECASTING"></a>TIMER-XL: LONG-CONTEXT TRANSFORMERS FOR UNIFIED TIME SERIES FORECASTING</h3><p>长上下文Transformer 统一的时间序列预测。</p><p>从题目入手：</p><ul><li>长文本：NLP领域的Transformer学习成千上万的token间依赖，传统只能学几百个token。</li><li>统一预测：做出改变：1维的token 预测 下一个token 改成→ 2维的(多变量)。</li></ul><p><img src="/images/DeepLearning/image-20250305012709401.png" alt="image-20250305012709401"></p><p>图中介绍了何为token，以及不同模态（语言模型、视觉模型、时序模型）Transformer处理的上下文长度。</p><p>总结本文做了两个工作：</p><p>​1.使用了NLP领域的Transformer应用到时序领域来，能处理更长的时间依赖；<br>​2.在Transformer中包含了单变量、多变量（多目标变量&#x2F;多协变量+一目标变量）。</p><p>模型：使用decoder-only的Transformer，利用不同长度的上下文来捕捉因果依赖关系。</p><blockquote><p>因果（Causality）通常指的是模型在处理序列数据时，只能使用当前时间点之前的信息，而不能“看到”未来的信息。</p><p>通过“自注意力”和“因果掩码”实现。</p><p><strong>使用因果掩码（Causal Masking）：</strong> 在计算**注意力权重（Attention Weights）**时，对未来的时间步置零，使得模型在计算第 ttt 个时间步的预测时，只能看到时间步 ≤t\leq t≤t 的数据。</p><p><strong>解码器架构（Decoder-Only Architecture）：</strong> 采用<strong>自回归（Autoregressive）</strong> 方式进行预测，即模型逐步预测每个时间步的值，并将已预测的值输入到后续时间步的计算中，而不是一次性输出整个序列。</p></blockquote><p>创新：1.提出了通用的TimeAttention机制；2.位置编码。</p><blockquote><p>其中TimeAttention中提到了：Kronecker-based mask 和 RoPE 两个技术。</p></blockquote><p><img src="/images/DeepLearning/image-20250305012634197.png" alt="image-20250305012634197"></p><p>此为模型结构图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Time Series A &amp; B</span><br>时序A(蓝色)，时序B(黄色) 被分割成多个Patch Token，作为输入。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Variable Dependency 变量依赖</span><br>变量A和B之间存在依赖关系，A的值受B影响，反之亦然(绿色箭头)。<br>依赖矩阵C记录了不同变量间的关联程度。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">不同时序建模方式</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">(a) 单变量 Univariate</span><br>只考虑单个时间序列 + 时间掩码(确保只能看到过去的信息) + 没有跨变量依赖关系<br><span class="hljs-meta prompt_"># </span><span class="language-bash">(b) 多变量 Multivariate</span><br>处理多个时间序列 + 变量依赖矩阵C全为1(变量间存在相互影响) + 时间掩码T(因果)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">(c) 带协变量 With Covariate B</span><br>A是目标变量，B是协变量 + C采用自定义依赖关系(A依赖A,B;B依赖B) + 时间掩码T(因果)<br></code></pre></td></tr></table></figure><p><code>Kronecker 乘积</code> $ C⊗T $ </p><p><strong>变量依赖矩阵(时间因果) $C$ 与时间掩码 $T$ 通过 Kronecker 乘积</strong>，将变量间的依赖关系 <strong>(C)</strong> 和时间序列的因果结构 <strong>(T)</strong> 结合，形成一个完整的 <strong>注意力掩码（Attention Mask）</strong>。<strong>保证 Transformer 既能考虑时间因果性，又能捕获变量之间的相互影响</strong>。</p><p><code>RoPE</code> 旋转位置编码：旨在为Transformer模型提供<strong>相对位置信息</strong>。</p><p>$RoPE(Q,K)&#x3D;QR_θK^T$</p><p>其中，$R_{\theta}$ 是一个基于位置索引 $p$ 和一个预设的基数 $θ$ 生成的旋转矩阵。</p><p>&#x3D;&#x3D;RoPE <strong>在注意力计算时，利用旋转变换引入相对位置信息，而不是直接添加位置编码</strong>。&#x3D;&#x3D;</p><p><code>可学习的标量参数（Scalars）</code></p><p>$Attention(Q,K,V)&#x3D;softmax(\frac{S_1⋅QK^T}{S_2·\sqrt{d}})V$</p><p>在注意力机制中，每个注意力头（Attention Head）通常会处理不同的子空间信息。可以使用<strong>可学习的标量参数</strong>来调整不同变量的贡献。</p><p><code>TimeAttention 计算公式</code></p><p>$TimeAttention(H)&#x3D;Softmax(\frac{Mask(C⊗T)+A}{\sqrt{d_k}})HW_v.$</p><p>$Mask()$ 的作用 $M_{i,j} &#x3D; 1$ 该位置$&#x3D;0$；$M_{i,j} &#x3D; 0$ 该位置$&#x3D;-∞$。相当于做了一步它和邻接矩阵相加，更改邻接矩阵的步骤，算是一个小优化。</p><p>$H$   特征矩阵</p><p>$W_v$ 投影矩阵</p><p>$d_k &#x3D; \frac{D}{head数量}$ 缩放因子（D是隐藏层维度）</p><h4 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h4><p>分别对：上下文长度、单变量预测、多变量预测、协变量预测、零样本做了对比实验。</p><p>又对：模型效率进行了实验。</p><p><img src="/images/DeepLearning/image-20250305022448722.png" alt="image-20250305022448722"></p><p><img src="/images/DeepLearning/image-20250305022501776.png" alt="image-20250305022501776"></p><p><img src="/images/DeepLearning/image-20250305022518724.png" alt="image-20250305022518724"></p><p><img src="/images/DeepLearning/image-20250305022531588.png" alt="image-20250305022531588"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用智能指针？"><a href="#为什么使用智能指针？" class="headerlink" title="为什么使用智能指针？"></a>为什么使用智能指针？</h3><p>智能指针使用的是RAII的思想，资源的获取和释放和对象的声明周期绑定(通过类)，避免手动释放内存，对象声明周期结束自动调用析构函数释放，<strong>避免内存泄漏</strong>。</p><p>比如悬空指针(指针指向的地址已经被销毁)，智能指针能避免这种情况发生。</p><blockquote><p>C++98提供了auto_ptr模板的解决方案 C++11新增了unique_ptr、shared_ptr、weak_ptr</p></blockquote><h3 id="auto-ptr-C-17中被完全移除-弃用"><a href="#auto-ptr-C-17中被完全移除-弃用" class="headerlink" title="auto_ptr(C++17中被完全移除&#x2F;弃用)"></a>auto_ptr(C++17中被完全移除&#x2F;弃用)</h3><p>auto_ptr是C++98中定义的智能指针模板，可以将new获得的地址赋值给auto_ptr类型的指针，当对象过期时，调用析构函数中的delete释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto_ptr声明方式：auto_ptr&lt;类型&gt; 变量名(new 类型);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">str_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这是一个字符串&quot;</span>))</span></span>;<br>auto_ptr&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ve_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>对于类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br>T *tptr = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">//只调用构造函数，不会调用析构函数，不会释放new出来的内存，需要手动delete</span><br><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;  <span class="hljs-comment">//等到tptr1的声明周期结束，还会调用析构函数(管理指针的类的析构)，再牵扯调用类的析构</span><br>cout &lt;&lt; tptr1-&gt;<span class="hljs-built_in">Display</span>() &lt;&lt; (*tptr).<span class="hljs-built_in">Display</span>() &lt;&lt; endl; <span class="hljs-comment">//智能指针重载了 *(返回普通对象) 和 -&gt;(返回指针对象) 运算符</span><br></code></pre></td></tr></table></figure><p>智能指针常用的三个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br><span class="hljs-comment">// get() 获取智能指针托管的指针地址</span><br>T *tmp = tptr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 一般不用这个操作</span><br>cout &lt;&lt; tmp-&gt;<span class="hljs-built_in">Display</span>();<br><span class="hljs-comment">// release() 取消智能指针对动态内存的托管</span><br>T *tmp2 = tptr.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//tptr不再指向原内存地址,指向NULL</span><br><span class="hljs-keyword">delete</span> tmp2;<br><span class="hljs-comment">//reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</span><br>tptr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//释放掉内存，将tptr指向NULL</span><br>tptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>()); <span class="hljs-comment">//释放掉内存，指向新的内存</span><br></code></pre></td></tr></table></figure><p>auto_ptr从C++11之后被抛弃的主要原因(<strong>被unique_ptr取代了</strong>)</p><ul><li>复制或赋值都会改变资源的所有权</li><li>在STL容器中使用非常危险，因为容器中的元素必须支持可复制和赋值(别把指针传入容器，就算使用了std::move()避免了，在容器中修改值也寄了)</li><li>不支持对象数组的内存管理(🚫auto_ptr&lt;int[]&gt; array(new int[5]);)因为auto_ptr并不会使用delete[]，会错误的使用delete释放，引发内存泄漏甚至崩溃(访问非法内存)</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>同auto_ptr的特性一样，有排他所有权模式：两个指针不能指向同一个资源</li><li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但是允许临时右值赋值构造和赋值</li><li>保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象</li><li>在容器中保存指针是安全的</li></ul><blockquote><p>使用 <code>std::move</code> 可以把左值转换成右值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>; <span class="hljs-comment">//p1被置为NULL，p3里是原p1指向的地址</span><br>p1 = std::<span class="hljs-built_in">move</span>(p2);                   <span class="hljs-comment">//同上，道理一样</span><br><br><span class="hljs-comment">//在 STL 容器中使用unique_ptr，不允许直接赋值</span><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec[<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">move</span>(vec[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">//支持对象数组的内存管理</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>除上述用法，其它与auto_ptr无差别。</p><p>初始化方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1(<span class="hljs-built_in">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1 = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>); //C++<span class="hljs-number">14</span>开始<br></code></pre></td></tr></table></figure><p>使用 <code>make_unique</code> 减少了手动使用new的需求；它将对象的构造函数和内存分配结合在一起，避免了潜在的内存泄漏；支持数组的安全初始化，自动使用delete[]释放数组；提供更好的(一丢丢) 性能和内存管理。</p><p>内存管理陷阱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;string&gt; p1, p2;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;内存管理陷阱&quot;</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(str);<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>(str); <span class="hljs-comment">//p2接管str指针，会先取消p1的托管，此时p1指向了NULL</span><br>cout &lt;&lt; *p1 &lt;&lt; endl; <span class="hljs-comment">//再使用p1时，会引发异常(内存错误)</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个指针变量共享内存。记录引用特定内存对象的智能指针数量，当复制时，引用计数+1，当智能指针析构时，引用计数-1，如果计数为0，代表已经没有指针指向这块内存，我们就可以释放了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">element_type* _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;    <span class="hljs-comment">//指向申请的内存</span><br>_Ref_count_base* _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;; <span class="hljs-comment">//指向引用计数</span><br></code></pre></td></tr></table></figure><p>1.引用计数的使用</p><p>调用use_count函数可以获得当前托管指针的引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br>p1 = p2;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//2</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p>2.构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br>T *tptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(tptr); <span class="hljs-comment">//托管tptr，不需要delete tptr了</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p1)</span></span>;<br><br>shared_ptr&lt;T[]&gt; p4;                      <span class="hljs-comment">//C++17后支持</span><br><span class="hljs-function">shared_ptr&lt;T[]&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;)</span></span>; <span class="hljs-comment">//C++17后支持</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>, DestructT())</span></span>;     <span class="hljs-comment">//空的指针，接受一个DestructT()类型的删除器，用它释放内存</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">8</span>), DestructT())</span></span>;<br></code></pre></td></tr></table></figure><p>3.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(up1)</span></span>;<br><span class="hljs-comment">//使用make_shared初始化对象，分配内存效率更高(推荐)</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>);<br>shared_ptr&lt;string&gt; up4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-string">&quot;string&quot;</span>);<br>shared_ptr&lt;T&gt; up5 = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-number">9</span>);<br><span class="hljs-comment">//赋值</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;<br>up6 = up7; <span class="hljs-comment">//int(10)的引用计数-1，int(11)的引用计数+1，up2共享int(11)给up1</span><br><span class="hljs-comment">//主动释放对象</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up8</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>up8 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//int(10)的引用计数-1，计数归零内存释放</span><br>up8 = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//作用同上</span><br><span class="hljs-comment">//重置</span><br>p.<span class="hljs-built_in">reset</span>();     <span class="hljs-comment">//将p重置为空指针，所管理的对象引用计数-1</span><br>p.<span class="hljs-built_in">reset</span>(p1);   <span class="hljs-comment">//将p重置为p1，p管理的对象计数-1，p接管的p1的对象计数+1</span><br>p.<span class="hljs-built_in">reset</span>(p1,d); <span class="hljs-comment">//同上，并使用d作为删除器</span><br><span class="hljs-comment">//交换</span><br>std::<span class="hljs-built_in">swap</span>(p1,p2); <span class="hljs-comment">//交换p1和p2管理的对象，原对象的引用计数不变</span><br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);      <span class="hljs-comment">//同上，swap()是shared_ptr中实现(重写)的，不需要加std</span><br></code></pre></td></tr></table></figure><p>shared_ptr使用陷阱</p><p>shared_ptr作为被管控的对象的成员时，小心因循环引用造成无法释放资源。</p><p>比如A类中有B类的智能指针，B类中有A类的智能指针，相互持有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解读：当useTrap()被调用，会初始化两个共享智能指针，spBoy指向Boy()内存，spGirl指向Girl()内存，然后进入交叉引用阶段，Boy()中有一个gF指针指向Girl()，Girl()中有一个bF指针指向Boy()。</p><img src="https://picx.zhimg.com/80/v2-3dc01c49b68a25febca39681a1fc9303_720w.png?source=d16d100b" alt="img" style="zoom:67%;" /><p>可以使用weak_ptr避免这种情况的发生。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>目的是为了配合shared_ptr而引用的一种智能指针来协助其工作的，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，它的构造和析构不会引起计数的增加或减少。</p><p>weak_ptr没有重载 * 和 -&gt;，但是可以使用lock获得一个可用的shared_ptr对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr wpGirl_1;<br><span class="hljs-function">weak_ptr <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>; <span class="hljs-comment">//使用shared_ptr构造</span><br>wpGirl_1 = spGirl;         <span class="hljs-comment">//允许共享指针赋值给弱指针</span><br><br>wpGirl_<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>();      <span class="hljs-comment">//也可以获得引用计数</span><br><br>shared_ptr&lt;Girl&gt; sp_girl;   <span class="hljs-comment">//必要的时候可以转换成共享指针</span><br>sp_girl = wpGirl_<span class="hljs-number">1.l</span>ock();  <span class="hljs-comment">//使用lock()</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>上述问题代码改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    weak_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接解决问题！</p><p>weak_ptr的expired函数用法：判断当前weak_ptr智能指针是否还有托管的对象，有返回false，无返回true</p><p>如果返回true，相当于use_count()&#x3D;0，已经没有托管对象了。可以在使用指针前加以判断，保证指针是有效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr&lt;<span class="hljs-type">int</span>&gt; g;<br><span class="hljs-keyword">if</span>(!g.<span class="hljs-built_in">expired</span>()) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<span class="hljs-comment">//有效</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="智能指针的使用陷阱"><a href="#智能指针的使用陷阱" class="headerlink" title="智能指针的使用陷阱"></a>智能指针的使用陷阱</h3><ul><li>不要把一个原生指针给多个智能指针管理；</li><li>记得使用u.release()的返回值，这个返回值是这块内存的唯一索引，没有释放的话就内存泄漏了；</li><li>禁止使用delete智能指针get()得到的指针；</li><li>禁止使用任何类型智能指针get()返回的地址去初始化另一个智能指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++11新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
