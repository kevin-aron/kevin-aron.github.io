<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++智能指针</title>
    <link href="/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/categories/C++11%E6%96%B0%E7%89%B9%E6%80%A7/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么使用智能指针？"><a href="#为什么使用智能指针？" class="headerlink" title="为什么使用智能指针？"></a>为什么使用智能指针？</h3><p>智能指针使用的是RAII的思想，资源的获取和释放和对象的声明周期绑定(通过类)，避免手动释放内存，对象声明周期结束自动调用析构函数释放，<strong>避免内存泄漏</strong>。</p><p>比如悬空指针(指针指向的地址已经被销毁)，智能指针能避免这种情况发生。</p><blockquote><p>C++98提供了auto_ptr模板的解决方案 C++11新增了unique_ptr、shared_ptr、weak_ptr</p></blockquote><h3 id="auto-ptr-C-17中被完全移除-弃用"><a href="#auto-ptr-C-17中被完全移除-弃用" class="headerlink" title="auto_ptr(C++17中被完全移除&#x2F;弃用)"></a>auto_ptr(C++17中被完全移除&#x2F;弃用)</h3><p>auto_ptr是C++98中定义的智能指针模板，可以将new获得的地址赋值给auto_ptr类型的指针，当对象过期时，调用析构函数中的delete释放内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// auto_ptr声明方式：auto_ptr&lt;类型&gt; 变量名(new 类型);</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">str_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这是一个字符串&quot;</span>))</span></span>;<br>auto_ptr&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ve_ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">array_ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>对于类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br>T *tptr = <span class="hljs-keyword">new</span> T; <span class="hljs-comment">//只调用构造函数，不会调用析构函数，不会释放new出来的内存，需要手动delete</span><br><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;  <span class="hljs-comment">//等到tptr1的声明周期结束，还会调用析构函数(管理指针的类的析构)，再牵扯调用类的析构</span><br>cout &lt;&lt; tptr1-&gt;<span class="hljs-built_in">Display</span>() &lt;&lt; (*tptr).<span class="hljs-built_in">Display</span>() &lt;&lt; endl; <span class="hljs-comment">//智能指针重载了 *(返回普通对象) 和 -&gt;(返回指针对象) 运算符</span><br></code></pre></td></tr></table></figure><p>智能指针常用的三个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">auto_ptr&lt;T&gt; <span class="hljs-title">tptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br><span class="hljs-comment">// get() 获取智能指针托管的指针地址</span><br>T *tmp = tptr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 一般不用这个操作</span><br>cout &lt;&lt; tmp-&gt;<span class="hljs-built_in">Display</span>();<br><span class="hljs-comment">// release() 取消智能指针对动态内存的托管</span><br>T *tmp2 = tptr.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//tptr不再指向原内存地址,指向NULL</span><br><span class="hljs-keyword">delete</span> tmp2;<br><span class="hljs-comment">//reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</span><br>tptr.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//释放掉内存，将tptr指向NULL</span><br>tptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>()); <span class="hljs-comment">//释放掉内存，指向新的内存</span><br></code></pre></td></tr></table></figure><p>auto_ptr从C++11之后被抛弃的主要原因(<strong>被unique_ptr取代了</strong>)</p><ul><li>复制或赋值都会改变资源的所有权</li><li>在STL容器中使用非常危险，因为容器中的元素必须支持可复制和赋值(别把指针传入容器，就算使用了std::move()避免了，在容器中修改值也寄了)</li><li>不支持对象数组的内存管理(🚫auto_ptr&lt;int[]&gt; array(new int[5]);)因为auto_ptr并不会使用delete[]，会错误的使用delete释放，引发内存泄漏甚至崩溃(访问非法内存)</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>同auto_ptr的特性一样，有排他所有权模式：两个指针不能指向同一个资源</li><li>无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但是允许临时右值赋值构造和赋值</li><li>保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象</li><li>在容器中保存指针是安全的</li></ul><blockquote><p>使用 <code>std::move</code> 可以把左值转换成右值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m Li Ming!&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I&#x27;m age 22.&quot;</span>))</span></span>;<br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(std::move(p1))</span></span>; <span class="hljs-comment">//p1被置为NULL，p3里是原p1指向的地址</span><br>p1 = std::<span class="hljs-built_in">move</span>(p2);                   <span class="hljs-comment">//同上，道理一样</span><br><br><span class="hljs-comment">//在 STL 容器中使用unique_ptr，不允许直接赋值</span><br>vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(p3));<br>vec[<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">move</span>(vec[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">//支持对象数组的内存管理</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">array</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>除上述用法，其它与auto_ptr无差别。</p><p>初始化方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1(<span class="hljs-built_in">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-built_in">std</span>::unique_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; p1 = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>); //C++<span class="hljs-number">14</span>开始<br></code></pre></td></tr></table></figure><p>使用 <code>make_unique</code> 减少了手动使用new的需求；它将对象的构造函数和内存分配结合在一起，避免了潜在的内存泄漏；支持数组的安全初始化，自动使用delete[]释放数组；提供更好的(一丢丢) 性能和内存管理。</p><p>内存管理陷阱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;string&gt; p1, p2;<br>string *str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;内存管理陷阱&quot;</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(str);<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>(str); <span class="hljs-comment">//p2接管str指针，会先取消p1的托管，此时p1指向了NULL</span><br>cout &lt;&lt; *p1 &lt;&lt; endl; <span class="hljs-comment">//再使用p1时，会引发异常(内存错误)</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>多个指针变量共享内存。记录引用特定内存对象的智能指针数量，当复制时，引用计数+1，当智能指针析构时，引用计数-1，如果计数为0，代表已经没有指针指向这块内存，我们就可以释放了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">element_type* _Ptr&#123;<span class="hljs-literal">nullptr</span>&#125;;    <span class="hljs-comment">//指向申请的内存</span><br>_Ref_count_base* _Rep&#123;<span class="hljs-literal">nullptr</span>&#125;; <span class="hljs-comment">//指向引用计数</span><br></code></pre></td></tr></table></figure><p>1.引用计数的使用</p><p>调用use_count函数可以获得当前托管指针的引用计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>;<br>p1 = p2;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//2</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><p>2.构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;T&gt; p1;<br>T *tptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>);<br>p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>(tptr); <span class="hljs-comment">//托管tptr，不需要delete tptr了</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p3</span><span class="hljs-params">(p1)</span></span>;<br><br>shared_ptr&lt;T[]&gt; p4;                      <span class="hljs-comment">//C++17后支持</span><br><span class="hljs-function">shared_ptr&lt;T[]&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;)</span></span>; <span class="hljs-comment">//C++17后支持</span><br><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>, DestructT())</span></span>;     <span class="hljs-comment">//空的指针，接受一个DestructT()类型的删除器，用它释放内存</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">8</span>), DestructT())</span></span>;<br></code></pre></td></tr></table></figure><p>3.初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up2</span><span class="hljs-params">(up1)</span></span>;<br><span class="hljs-comment">//使用make_shared初始化对象，分配内存效率更高(推荐)</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; up3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>);<br>shared_ptr&lt;string&gt; up4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-string">&quot;string&quot;</span>);<br>shared_ptr&lt;T&gt; up5 = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-number">9</span>);<br><span class="hljs-comment">//赋值</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>))</span></span>;<br>up6 = up7; <span class="hljs-comment">//int(10)的引用计数-1，int(11)的引用计数+1，up2共享int(11)给up1</span><br><span class="hljs-comment">//主动释放对象</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up8</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>up8 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//int(10)的引用计数-1，计数归零内存释放</span><br>up8 = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//作用同上</span><br><span class="hljs-comment">//重置</span><br>p.<span class="hljs-built_in">reset</span>();     <span class="hljs-comment">//将p重置为空指针，所管理的对象引用计数-1</span><br>p.<span class="hljs-built_in">reset</span>(p1);   <span class="hljs-comment">//将p重置为p1，p管理的对象计数-1，p接管的p1的对象计数+1</span><br>p.<span class="hljs-built_in">reset</span>(p1,d); <span class="hljs-comment">//同上，并使用d作为删除器</span><br><span class="hljs-comment">//交换</span><br>std::<span class="hljs-built_in">swap</span>(p1,p2); <span class="hljs-comment">//交换p1和p2管理的对象，原对象的引用计数不变</span><br>p<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(p2);      <span class="hljs-comment">//同上，swap()是shared_ptr中实现(重写)的，不需要加std</span><br></code></pre></td></tr></table></figure><p>shared_ptr使用陷阱</p><p>shared_ptr作为被管控的对象的成员时，小心因循环引用造成无法释放资源。</p><p>比如A类中有B类的智能指针，B类中有A类的智能指针，相互持有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    shared_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解读：当useTrap()被调用，会初始化两个共享智能指针，spBoy指向Boy()内存，spGirl指向Girl()内存，然后进入交叉引用阶段，Boy()中有一个gF指针指向Girl()，Girl()中有一个bF指针指向Boy()。</p><p><img src="https://picx.zhimg.com/80/v2-3dc01c49b68a25febca39681a1fc9303_720w.png?source=d16d100b" alt="img"></p><p>添加图片注释，不超过 140 字（可选）</p><p>可以使用weak_ptr避免这种情况的发生。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>目的是为了配合shared_ptr而引用的一种智能指针来协助其工作的，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，它的构造和析构不会引起计数的增加或减少。</p><p>weak_ptr没有重载 * 和 -&gt;，但是可以使用lock获得一个可用的shared_ptr对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr wpGirl_1;<br><span class="hljs-function">weak_ptr <span class="hljs-title">wpGirl_2</span><span class="hljs-params">(spGirl)</span></span>; <span class="hljs-comment">//使用shared_ptr构造</span><br>wpGirl_1 = spGirl;         <span class="hljs-comment">//允许共享指针赋值给弱指针</span><br><br>wpGirl_<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>();      <span class="hljs-comment">//也可以获得引用计数</span><br><br>shared_ptr&lt;Girl&gt; sp_girl;   <span class="hljs-comment">//必要的时候可以转换成共享指针</span><br>sp_girl = wpGirl_<span class="hljs-number">1.l</span>ock();  <span class="hljs-comment">//使用lock()</span><br>sp_girl = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>上述问题代码改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Boy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGirlFriend</span><span class="hljs-params">(shared_ptr&lt;Girl&gt; _girlFriend)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;girlFriend = _girlFriend;<br>    &#125;<br>    shared_ptr&lt;Girl&gt; girlFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Girl</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBoyFriend</span><span class="hljs-params">(shared_ptr&lt;Boy&gt; _boyFriend)</span> </span>&#123;<br><span class="hljs-keyword">this</span>-&gt;boyFriend = _boyFriend;<br>    &#125;<br>    weak_ptr&lt;Boy&gt; boyFriend;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useTrap</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;Boy&gt; <span class="hljs-title">spBoy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Boy())</span></span>;<br><span class="hljs-function">shared_ptr&lt;Girl&gt; <span class="hljs-title">spGirl</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Girl())</span></span>;<br><span class="hljs-comment">// 陷阱用法</span><br><span class="hljs-comment">//spBoy-&gt;setGirlFriend(spGirl);</span><br>spGirl-&gt;<span class="hljs-built_in">setBoyFriend</span>(spBoy);<br><span class="hljs-comment">// 此时boy和girl的引用计数都是2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接解决问题！</p><p>weak_ptr的expired函数用法：判断当前weak_ptr智能指针是否还有托管的对象，有返回false，无返回true</p><p>如果返回true，相当于use_count()&#x3D;0，已经没有托管对象了。可以在使用指针前加以判断，保证指针是有效的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr&lt;<span class="hljs-type">int</span>&gt; g;<br><span class="hljs-keyword">if</span>(!g.<span class="hljs-built_in">expired</span>()) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<span class="hljs-comment">//有效</span><br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="智能指针的使用陷阱"><a href="#智能指针的使用陷阱" class="headerlink" title="智能指针的使用陷阱"></a>智能指针的使用陷阱</h3><ul><li>不要把一个原生指针给多个智能指针管理；</li><li>记得使用u.release()的返回值，这个返回值是这块内存的唯一索引，没有释放的话就内存泄漏了；</li><li>禁止使用delete智能指针get()得到的指针；</li><li>禁止使用任何类型智能指针get()返回的地址去初始化另一个智能指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++11新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
